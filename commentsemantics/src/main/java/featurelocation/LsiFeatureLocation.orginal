package featurelocation;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;

import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.FieldType;
import org.apache.lucene.index.IndexOptions;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.store.Directory;
import org.apache.lucene.store.FSDirectory;

import pitt.search.semanticvectors.BuildIndex;
import pitt.search.semanticvectors.CloseableVectorStore;
import pitt.search.semanticvectors.FlagConfig;
import pitt.search.semanticvectors.LuceneUtils;
import pitt.search.semanticvectors.Search;
import pitt.search.semanticvectors.SearchResult;
import pitt.search.semanticvectors.VectorSearcher;
import pitt.search.semanticvectors.VectorStoreReader;

public class LsiFeatureLocation implements FeatureLocation 
{
	static final String DOCINDEX_PATH = "document_index";
	
	static final String[] COMMAND_LINE_ARGS = {"-vectortype", "real", "-dimension", "2"};
	static final FlagConfig FLAG_CONFIG = FlagConfig.getFlagConfig(COMMAND_LINE_ARGS);
	
	private StandardAnalyzer standardAnalyzer = null;
	private Directory directory = null;
	private IndexWriter writer = null;
	private FieldType fieldType = null;
	
	public LsiFeatureLocation()
	{
		reset();
	}
	
	@Override
	public void prepareDocument(String fileName, List<String> artefact, List<String> comments) 
	{
		Field field1 = new Field("path", fileName, fieldType);		
		Field field2 = new Field("contents", String.join(" ", comments), fieldType);

		Document document = new Document();
		document.add(field1);
		document.add(field2);

		try {
			writer.addDocument(document);

		} catch (IOException e) {
			e.printStackTrace();
		}	
		
		
		//creat documents for indexing
		String str =  String.join(" ", comments);
	    BufferedWriter writer;
		try {
			writer = new BufferedWriter(new FileWriter("c:\\test\\testdata\\" + fileName));
			writer.write(str);		    
		    writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
	}

	@Override
	public void reset() 
	{
		try {
			//clean up index dir
			File index = new File(DOCINDEX_PATH);
			
			String[]entries = index.list();
			if(entries != null) 
			{
				for(String s: entries){
				    File currentFile = new File(index.getPath(),s);
				    currentFile.delete();
				}
				index.delete();
			}
			
			//create testdata path
			/*File testdata = new File("c:\\test\\testdata");
			if(!testdata.exists())
				testdata.mkdir();
			*/
			
			
			standardAnalyzer = new StandardAnalyzer();			
			directory = FSDirectory.open(new File(DOCINDEX_PATH).toPath());
			
			IndexWriterConfig config = new IndexWriterConfig(standardAnalyzer); 
			writer = new IndexWriter(directory, config);
			
			//initialize field
			fieldType = new FieldType();
			fieldType.setStoreTermVectors(true);
			fieldType.setTokenized(true);
			fieldType.setStored(true);
			fieldType.setStoreTermVectorOffsets(true);
			fieldType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);
			
		}
		catch(IOException e) {
			e.printStackTrace();
		}			
	}
	
	public void printSimilarDocuments() throws IOException
	{	
		writer.close();			
		
		//Create document indexes from comments
	    /*File testDataPath = new File("c:\\test\\testdata");
	    if (!testDataPath.isDirectory()) {
	      throw new IOException("No directory for test data at: " + testDataPath.getAbsolutePath());
	    }
	    
	    IndexFilePositions.main(new String[] {"-luceneindexpath", DOCINDEX_PATH, testDataPath});
	   */
	    
	    String[] buildArgs = new String("-dimension 200 -luceneindexpath document_index").split("\\s+");
		
		try {
		      BuildIndex.main(buildArgs);
		      
		      //method1
		      String[] searchArgs = new String("-queryvectorfile termvectors.bin -searchvectorfile docvectors.bin -luceneindexpath document_index -numsearchresults 3 block line java").split("\\s+");
		      
		      List<SearchResult> testresults = Search.runSearch(FlagConfig.getFlagConfig(searchArgs));
		      for (SearchResult result : testresults) {
		          String filename = (String) result.getObjectVector().getObject();
		          System.out.println("score:" + result.getScore() + "  file:" + filename);
		      }
		      
		      
		      //method2
		      FlagConfig config = FlagConfig.getFlagConfig(searchArgs);
		      CloseableVectorStore queryVecReader = VectorStoreReader.openVectorStore(config.termvectorsfile(), config); 
		      CloseableVectorStore resultsVecReader = VectorStoreReader.openVectorStore(config.docvectorsfile(), config);
		      LuceneUtils luceneUtils = new LuceneUtils(config);; 
		      VectorSearcher  vecSearcher = new VectorSearcher.VectorSearcherCosine( 
		                      queryVecReader, resultsVecReader, luceneUtils, config, new String[] {"block", "line", "java"}); 
		      LinkedList<SearchResult> results1 = vecSearcher.getNearestNeighbors(3);

		      for (SearchResult result: results1) {
		        System.out.println(String.format(
		            "%f:%s",
		            result.getScore(),
		            result.getObjectVector().getObject().toString()));
		      }	      
		      
		}
		catch (Exception e) {
		      e.printStackTrace();
		}
		
		
	}
}
